[{"authors":["admin"],"categories":null,"content":"I\u0026rsquo;m Sebastián Ferrada, a Doctoral Candidate at the Millenium Institute for Foundational Research on Data at Universidad de Chile. My research interests include Information Retrieval, Data Mining \u0026amp; Visualization, Multimedia Databases and Linked Data. I\u0026rsquo;m currently developing my PhD thesis regarding the inclusion of similarity operators on SPARQL queries: it\u0026rsquo;s scalability, efficiency and use-cases.\nBesides research I really enjoy teaching. Currently I\u0026rsquo;m teaching the Relational Databases Course for undergrads and at the Data Science Diploma, at the Department of Computer Science (DCC) and I have worked as T.A. in many other areas and courses such as Algorithm Analysis and Programming Design Methodologies, you may find a complete list having a look at my resumé. I have also done some extracurricular volunteer teaching at Preumed, Capsocial and Apoyo Escolar.\n","date":1540835003,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1540835003,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"http://www.sferrada.com/author/sebastian-ferrada-aliaga/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/sebastian-ferrada-aliaga/","section":"authors","summary":"I\u0026rsquo;m Sebastián Ferrada, a Doctoral Candidate at the Millenium Institute for Foundational Research on Data at Universidad de Chile. My research interests include Information Retrieval, Data Mining \u0026amp; Visualization, Multimedia Databases and Linked Data.","tags":null,"title":"Sebastián Ferrada Aliaga","type":"authors"},{"authors":["Sebastián Ferrada","Benjamin Bustos","and Aidan Hogan"],"categories":null,"content":"","date":1596254400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1596254400,"objectID":"526031fc432bb3019cb8debc2d0c65e5","permalink":"http://www.sferrada.com/publication/ferrada-simjoins-2020/","publishdate":"2020-08-01T00:00:00-04:00","relpermalink":"/publication/ferrada-simjoins-2020/","section":"publication","summary":"We propose techniques that support the efficient computation of multidimensional similarity joins in an RDF/SPARQL setting, where similarity in an RDF graph is measured with respect to a set of attributes selected in the SPARQL query. While similarity joins have been studied in other contexts, RDF graphs present unique challenges. We discuss how a similarity join operator can be included in the SPARQL language, and investigate ways in which it can be implemented and optimised. We devise experiments to compare three similarity join algorithms over two datasets. Our results reveal that our techniques outperform DBSimJoin: a PostgreSQL extension that supports similarity joins.","tags":["SPARQL","Similarity Joins","Wikidata"],"title":"Extending SPARQL with Similarity Joins","type":"publication"},{"authors":["Sebastián Ferrada","Benjamin Bustos","Nora Reyes"],"categories":null,"content":"","date":1582513200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582513200,"objectID":"457305eceaf0c98484f7b17b865991f9","permalink":"http://www.sferrada.com/publication/ferrada-simple-2020/","publishdate":"2020-02-24T00:00:00-03:00","relpermalink":"/publication/ferrada-simple-2020/","section":"publication","summary":"Similarity join is a key operation in metric databases. It retrieves all pairs of elements that are similar. Solving such a problem usually requires comparing every pair of objects of the datasets, even when indexing and ad hoc algorithms are used. We propose a simple and efficient algorithm for the computation of the approximated k nearest neighbor self-similarity join. This algorithm computes $\\Theta(3/2)$ distances and it is empirically shown that it reaches an empirical precision of 46% in real-world datasets. We provide a comparison to other common techniques such as Quickjoin and Locality-Sensitive Hashing and argue that our proposal has a better execution time and average precision.","tags":null,"title":"An efficient algorithm for approximated self-similarity joins in metric spaces","type":"publication"},{"authors":null,"categories":null,"content":"","date":1581444000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1581444000,"objectID":"c125a3bca93caec0c8c8ae8888b993be","permalink":"http://www.sferrada.com/talk/iswc2020/","publishdate":"2020-02-11T15:00:00-03:00","relpermalink":"/talk/iswc2020/","section":"talk","summary":"RDF datasets are often made accessible over the Web through a SPARQL endpoint where users typically write queries requesting matches on the content. For instance, in Wikidata, a SPARQL query may request 'the names and nationalities of laureates of the Nobel Prize in Literature that have fought in a war'. However, there are times when an exact match is not what users need; instead they wish to write a similarity query, for which there is no declarative support in the SPARQL standard. Hence a query to obtain 'the Latin American country with the most similar population and GDP to Italy cannot be written declaratively in SPARQL; even if the query were expressed with distances defined using low-level numeric operators, the SPARQL engine is unlikely to know how to optimise such a query, resorting to brute-force evaluation. On the other hand, the potential applications for similarity queries in SPARQL are numerous, including: entity comparison and linking, multimedia retrieval, similarity graphs, pattern recognition, data integration, as well as domain use-cases, such as protein similarity computation. In this talk, we motivate similarity-based queries for SPARQL and present a system for executing such queries over RDF graphs and integrating them with SPARQL including syntax discussion, query planning and optimisation, and novel use-cases.","tags":["Similarity Joins","SPARQL","Web Image Retrieval","Semantic Web"],"title":"Extending  SPARQL with Similarity Joins","type":"talk"},{"authors":null,"categories":null,"content":"","date":1581001200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1581001200,"objectID":"cd0c98f8a192b38112a18578e187f026","permalink":"http://www.sferrada.com/talk/insight-visit-20/","publishdate":"2020-02-06T12:00:00-03:00","relpermalink":"/talk/insight-visit-20/","section":"talk","summary":"RDF datasets are often made accessible over the Web through a SPARQL endpoint where users typically write queries requesting matches on the content. For instance, in Wikidata, a SPARQL query may request 'the names and nationalities of laureates of the Nobel Prize in Literature that have fought in a war'. However, there are times when an exact match is not what users need; instead they wish to write a similarity query, for which there is no declarative support in the SPARQL standard. Hence a query to obtain 'the Latin American country with the most similar population and GDP to Italy cannot be written declaratively in SPARQL; even if the query were expressed with distances defined using low-level numeric operators, the SPARQL engine is unlikely to know how to optimise such a query, resorting to brute-force evaluation. On the other hand, the potential applications for similarity queries in SPARQL are numerous, including: entity comparison and linking, multimedia retrieval, similarity graphs, pattern recognition, data integration, as well as domain use-cases, such as protein similarity computation. In this talk, we motivate similarity-based queries for SPARQL and present a system for executing such queries over RDF graphs and integrating them with SPARQL including syntax discussion, query planning and optimisation, and novel use-cases.","tags":["Similarity Joins","SPARQL","Web Image Retrieval","Semantic Web"],"title":"Similarity Joins in SPARQL","type":"talk"},{"authors":["Sebastián Ferrada Aliaga"],"categories":null,"content":"Al diseñar las relaciones que deben formar parte de un esquema relacional de bases de datos hay ciertos aspectos que se deben considerar de forma que se asegure que al agregar los datos en el esquema estos no presenten anomalías. En este artículo, voy a discutir distintas anomalías que pueden presentarse en esquemas relacionales y cómo pueden ser erradicados utilizando formas normales. Las formas normales son condiciones que todas las tablas de un esquema deben cumplir para así garantizar ciertas propiedades deseables. Las formas normales fueron propuestas principalmente por Edgar F. Codd durante los 70s.\nPara entender de mejor forma las condiciones que se requieren en cada forma normal, es recomendable que conozcas lo que es una llave y una dependencia funcional en el modelo relacional. En este post puedes encontrar definiciones y ejemplos también.\nVamos a guiar la explicación a través de una base de datos que mantiene el registro de los Pokémon que son capturados por los distintos entrenadores. En la Tabla 1, se muestra una forma sobre cómo organizar nuestros datos. La tabla contiene una columna con el identificador del entrenador y la segunda contiene una lista con las criaturas capturadas por dicho entrenador. La llave de la tabla es el nombre del entrenador por lo que se muestra en negrita y cursiva.\n    Entrenador Pokemon     Ash [Pikachu, Caterpie, Charmander, \u0026hellip;]   Misty [Staryu, Goldeen, Starmie, \u0026hellip;]   Gary [Krabby, Nidoking, Arcanine, \u0026hellip;]     Tabla 1: Entrenadores y sus Pokémon  Como se puede adivinar, es al menos extraño el manejar listas de elementos en una base de datos relacional. El utilizar ese tipo de estructuras en un atributo de una tabla puede producir dificultades al momento de implementar la base de datos. ¿Las colecciones pueden tener un tamaño máximo? ¿Cómo busco, agrego, ordeno o elimino eficientemente un elemento de la colección?\n¿Cómo se puede solucionar? La solución más ingenua, podría ser agregar más columnas, una para cada Pokémon atrapado. Esto supone nuevos problemas: ¿Cuántas columnas son suficientes? ¿Qué pasa con las columnas que no son utilizadas? ¿Cómo saber en cuál columna agregar la captura?\nPor lo general, la solución a este tipo de problemas es utilizar las llaves de ambas entidades relacionadas. En el caso del ejemplo, serían tanto el nombre del entrenador como el del Pokémon. El resultado puede apreciarse en la Tabla 2. Como un entrenador puede tener varios Pokémon tanto el nombre del entrenador como el nombre del Pokémon son la llave de la tabla. (Efectivamente esto restringe que un mismo entrenador capture dos pokémon del mismo nombre. ¿Cómo solucionar esto?)\n    Entrenador Pokemon     Ash Pikachu   Ash Caterpie   Ash Charmander   Misty Staryu   \u0026hellip; \u0026hellip;     Tabla 2: Entrenadores y sus Pokémon, un valor por celda  Cuando tenemos una relación como la de la Tabla 2, decimos que cada atributo tiene valores atómicos, es decir, valores que no son colecciones (conjuntos, listas, etc.). Este tipo de relaciones están en Primera Forma Normal.\nSupongamos que ahora que tenemos más información sobre el entrenador, sobre el Pokémon capturado y sobre la captura en sí. Por ejemplo, queremos almacenar la ciudad de la que el entrenador proviene, la salud y tipo del Pokémon capturado y la fecha y hora de la captura. Si seguimos con lo que veníamos haciendo en la Tabla 2, podríamos proponer un esquema como el que se ve en la Tabla 3. Podemos ver que la llave sigue siendo el nombre del entrenador y el del pokémon, sin embargo, al agregar también la fecha de captura a la llave podemos admitir que un entrenador capture más de un pokémon de la misma especie en momentos diferentes.\n    Entrenador Origen Pokemon Tipo HP Fecha Captura     Ash Pueblo Paleta Pikachu Eléctico 35 01-04-1997 10:20   Ash Pueblo Paleta Caterpie Insecto 45 02-04-1997 11:34   Ash Pueblo Paleta Charmander Fuego 39 05-04-1997 19:12   Misty Ciudad Celeste Staryu Agua 30 22-03-1995 09:44    Tabla 3: Entrenadores y sus Pokémon, con datos del entrenador, Pokémon y captura\n En el modelo de la Tabla 3, podemos encontrar varios problemas. Primero notamos que hay redundancia, pues cada vez que un entrenador capture un nuevo pokémon debemos repetir su ciudad de origen. Esto conlleva varias anomalías consigo, las cuales vamos a enumerar:\n Anomalía de Actualización: Si quisieramos modificar la ciudad de origen de un entrenador debemos asegurarnos de cambiarla correctamente en todas las filas que se refieren al entrenador. El no hacerlo, lleva a un estado inconsistente de la base de datos. Anomalía de Inserción: No podemos agregar un nuevo entrenadoral sistema si es que no ha capturado ningún pokémon aún. Esto pues la columna pokémon es parte de la llave y por lo tanto no admite valores nulos. Lo mismo con un pokémon, no tendremos registro de la especie o el tipo si nadie lo ha capturado. Anomalía de Borrado: Si un entrenador decide liberar a todos sus pokémon capturados, ¿qué hacemos con él? ¿Borramos todos sus datos?  ¿Cuál es el origen de estas anomalías? En este caso se debe a que hay atributos cuyo valor depende solo del entrenador. En este caso, la ciudad de origen depende del entrenador. Por otro lado, hay atributos que dependen solo del pokémon en cuestión, como el tipo. La salud del pokémon es un caso distinto, pues al contrario del tipo, no depende solo del pokemon del que se trata, sino que también depende del entrenador y de cuándo fue capturado1. Cuando se define una llave en una tabla, se espera que todos los atributos no-primos dependan de todos los atributos de la llave en conjunto, no solo de una parte de ésta. Eso es lo que en este caso produce las anomalías: hay atributos no primos que no dependen funcionalmente de la llave completa, sino que de un subconjunto (propio2) de ésta.\nEntonces, la Segunda Forma Normal (2NF) indica que un esquema está en primera forma normal y además, ningún atributo no primo depende funcionalmente de algún subconjunto propio de alguna de las llaves candidatas. También puede leerse como que todos los atributos no primos deben depender funcionalmente de todas las llaves candidatas completas.\nNuestro esquema de Tabla 3 no cumple con la segunda forma normal. La única llave candidata (y por lo tanto la llave primaria) es {Entrenador, Pokemon, Fecha} y tenemos las dependencias funcionales Entrenador $\\rightarrow$ Origen y Pokémon $\\rightarrow$ Tipo que violan 2NF pues Entrenador y Pokemon son subconjuntos propios de la llave primaria. ¿Cómo podemos lograr 2NF? En este caso en particular basta con tener una tabla para los entrenadores, otra para las especies de pokémon y otra para las capturas. En las tablas 4, 5 y 6 podemos encontrar el resultado de la normalización. Bastó en este caso con tomar las dependencias funcionales Entrenador $\\rightarrow$ Origen y Pokémon $\\rightarrow$ Tipo y extraerlas en tablas aparte. Finalmente, se agrega la tabla de capturas.\n    Entrenador Origen     Ash Pueblo Paleta   Misty Ciudad Celeste   Gary Pueblo Paleta    Tabla 4: Entrenadores y sus ciudades de origen\n   Pokemon tipo     Pikachu Eléctrico   Caterpie Insecto   Staryu Agua    Tabla 5: Especies de pokémon y sus tipos\n   Entrenador Pokemon HP Fecha Captura     Ash Pikachu 35 01-04-1997 10:20   Ash Caterpie 45 02-04-1997 11:34   Ash Charmander 39 05-04-1997 19:12   Misty Staryu 30 22-03-1995 09:44    Tabla 6: Entrenadores y sus pokémon\n El conjunto de las tablas 4, 5 y 6 cumple ahora con 2NF. Supongamos ahora que además del pueblo de origen del entrenador, queremos también saber la región de la que provienen, como se ve en la Tabla 7. En dicha tabla, es fácil notar que se cumple la dependencia funcional Origen $\\rightarrow$ Región. La existencia de esta dependencia facilita la aparición de las anomalías que discutimos anteriormente. Por ejemplo, si queremos modificar el pueblo de origen, tenemos que tomar en cuenta que la región tal vez también debería cambiar. La naturaleza del problema es distinta a la anterior. Acá no hay una dependencia parcial a una llave, sino que hay atributos no primos determinando funcionalmente a otros.\n    Entrenador Origen Región     Ash Pueblo Paleta Kanto   Misty Ciudad Celeste Kanto   Gary Pueblo Paleta Kanto   Professor Kukui Hau\u0026rsquo;oli Alola    Tabla 7: Entrenadores y sus ciudades y regiones de origen\n La Tercera Forma Normal (3NF) nos permite eliminar este tipo de anomalías. Un esquema está en 3NF sí está en segunda forma normal y ningún atributo no primo depende transitivamente de una llave candidata. La última condición también puede expresarse como que todos los atributos están determidados funcionalmente solo por las llaves candidatas y no por atributos no primos. En el caso de la Tabla 7 tenemos la Región depende transitivamente de la llave: Entrenador $\\rightarrow$ Origen $\\rightarrow$ Región, por lo tanto nuestra tabla no está en 3NF.\nPara normalizar una tabla que no está en 3NF, se puede utilizar el siguiente algoritmo (aunque en la mayoría de los casos solo basta usar el sentido común):\nINPUT: (R, F) R un esquema y F un conjunto de relaciones funcionales OUTPUT: El esquema normalizado F` := reducir(F) por cada X-\u0026gt;A en F`: Crear esquema (X U A, X-\u0026gt;A) Si en los esquemas creados no está la llave de (R, F), agregarla\t En reducir, lo que se hace es eliminar dependencias funcionales redundantes y dejarlas de la forma $X \\rightarrow A$ donde A es el conjunto de todos los atributos que dependen funcionalmente de X. Finalmente, se agrega la llave en caso de ser necesario. En nuestro ejemplo, las dependencias funcionales son (1) Entrenador $\\rightarrow$ Origen, (2) Entrenador $\\rightarrow$ Región y (3) Origen $\\rightarrow$ Región, entonces las tablas resultantes van a ser (Entrenador, Origen) y (Origen, Región) pues la (2), al ser transitiva de (1) y (3) se elimina. No es necesario agregar una tabla para la llave pues es simplemente Entrenador. La primera tabla puede apreciarse en Tabla 4 y la segunda en Tabla 8.\n    Pueblo Región     Pueblo Paleta Kanto   Ciudad Celeste Kanto   Hau\u0026rsquo;oli Alola    Tabla 8: Pueblos y las regiones a las que pertenecen\n ¿Estamos listos entonces? Falta un poco, aunque muchas veces se considera que un esquema en 3NF está lo suficientemente normalizado, aún hay ciertas cosas que pueden surgir.\nSupongamos ahora una tabla para guardar los duelos contra líderes de gimnasio. Vamos a suponer que un gimnasio puede tener solo un líder y que ese líder pertenece solo a un gimnasio. Podemos ver datos de ejemplo en la Tabla 9.\n    Lider Entrenador Gimnasio Fecha Ganador     Brock Ash Ciudad Plateada 03-04-1997 Brock   Brock Ash Ciudad Plateada 04-04-1997 Nadie   Misty Ash Ciudad Celeste 18-04-1997 Empate    Tabla 9: Registro de duelos en gimnasios\n Podemos inferir que una llave es esta tabla es $\\set{Lider, Entrenador, Fecha}$, pero dadas las dependencias funcionales {Lider}$\\rightarrow${Gimnasio} y {Gimnasio}$\\rightarrow${Lider} tenemos que otra llave candidata es {Entrenador, Gimnasio, Fecha}. Dadas las definiciones anteriores, la Tabla 9 está en 3FN. Sin embargo, aún pueden surgir anomalías de edición: ¿Qué pasa si queremos cambiar el nombre del gimnasio? Es requerido cambiarlo en todas partes. ¿Entonces normalizar hasta 3NF no es suficiente? Pues hay una forma de normalización superior a 3NF que evita este tipo de problemas.\nUn esquema está en Forma Normal de Boyce-Codd (FNBC) si para cada una de sus dependencias funcionales $X\\rightarrow Y$, $X$ es una superllave. Así de simple. En la Tabla 9, vemos que las dependencias funcionales entre Lider y Gimnasio violan el principio de Boyce-Codd y esto es lo que produce las anomalías. En general es extraño encontrar tablas que estén en 3FN y no en FNBC. Esto sucede cuando en una tabla 3FN existen llaves candidatas que se traslapan, es decir, que comparten atributos.\nEl algoritmo que se sigue para normalizar es el siguiente:\nInput: C ={(R0, F0)} # Esquema y dependencias iniciales Output: N # Esquema normalizado en FNBC for (R, F) in C: if (R, F) no está en FNBC: tomar X -\u0026gt; Y en F que viola FNBC C = C U (R-X, F1) # F1 son las df sobre los atributos en R-X C = C U (XY, F2) # F2 son las df sobre los atributos en XY  Entonces en el caso de la Tabla 9, tomamos una de las dependencias que viola FNBC, {lider}$\\rightarrow${gimnasio} y separamos el esquema en dos el primero con los atributos {lider, entrenador, fecha, ganador} y el otro con {lider, gimnasio}. Como ambas tablas resultantes quedaron en FNBC, el esquema ya está completamente normalizado.\nPara cerrar, quiero mencionar dos cosas. La primera, es que existen la cuarta, quinta y sexta formas normales, las cuales tratan de reparar anomalías cada vez más difíciles de encontrar en el mundo real. La segunda, es que la existencia de estas reglas y definiciones para mejorar el diseño relacional se sugieren principalmente para evitar las anomalías, sin embargo, es posible que se esté desarrollando una aplicación donde hayan otros elementos que sean más críticos que la normalización de las tablas, por lo que no hay que ser puristas, sino que tomar en cuenta el dominio y requisitos de lo que se está haciendo antes de llegar y dejar todo en sexta forma normal. Hay escenarios en los que se prefiere tener redundancia para aumentar la eficiencia antes que tener que realizar joins entre miles de tablas. Hay escenarios en los que se prefiere lo contrario.\nReferencias  Codd, Edgar F. \u0026ldquo;A relational model of data for large shared data banks.\u0026rdquo; Communications of the ACM 13.6 (1970): 377-387. Codd, Edgar F. \u0026ldquo;Recent Investigations into Relational Data Base Systems.\u0026rdquo; IBM Research Report RJ1385 (April 23, 1974). Ramakrishnan, Raghu, and Johannes Gehrke. Database management systems. McGraw Hill, 2000.    Esta diferencia ocurre pues un pokémon es una especie y una instancia a la vez: todos los Pikachu son eléctricos, pero cada uno tiene un HP distinto. La forma de diferenciar dos Pikachu distintos, es por el entrenador que los capturó. \u0026#x21a9;\u0026#xfe0e;\n Un subconjunto propio es un subconjunto con cardinalidad estrictamente menor que el conjunto original, es decir $R\\subsetneq S$ \u0026#x21a9;\u0026#xfe0e;\n   ","date":1540835003,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1540835003,"objectID":"ed3af88e6ea1fd7cc0adb468bfef22b3","permalink":"http://www.sferrada.com/post/normal-forms/","publishdate":"2018-10-29T14:43:23-03:00","relpermalink":"/post/normal-forms/","section":"post","summary":"Al diseñar las relaciones que deben formar parte de un esquema relacional de bases de datos hay ciertos aspectos que se deben considerar de forma que se asegure que al agregar los datos en el esquema estos no presenten anomalías.","tags":["Databases","Relational Model","Database Normalization","Normal Forms"],"title":"Formas Pokenormales","type":"post"},{"authors":["Sebastián Ferrada Aliaga"],"categories":null,"content":"Este post provee de una introducción al concepto de llaves y dependencias funcionales en el campo de la teoría de las bases de datos relacionales. Está guiado por ejemplos, pero se presentan también algunas de las formalidades matemáticas. Si encuentras algún error o hay algo que no se logra entender muy bien, por favor deja un comentario debajo.\nLlaves En el modelo relacional trabajamos con conjuntos de tuplas que se almacenan en una relación dada. Como en un conjunto no se permiten elementos repetidos es necesario que cada tupla tenga una forma de identificarse y diferenciarse de las otras. La forma de identificar tuplas es utilizando el concepto de llave:\n Una llave es un conjunto de atributos de una relación, tal que ningún par de tuplas de la relación tiene los mismos valores en dichos atributos  Por ejemplo, consideremos los datos de la Tabla 1. Una llave trivial para cualquier relación es el conjunto de todos los atributos. En este caso {vino, año, cepa, presentación}. Una llave más pequeña puede ser {vino, cepa} o {año, presentación} (considerando solo estos datos). Dicho lo anterior, es conveniente recalcar que las llaves no deben seleccionarse condicionadas a los datos, sino que considerando la semántica de las relaciones y atributos.\n   Vino año cepa presentación     130 2018 Cabernet 750cc   Clos de Paine 2014 Cabernet 750cc   Santelena 2018 Sauvignon Blanc 2000cc    Ahora vamos con un par de definiciones. Una superllave es cualquier llave de una relación. Todas las mencionadas en el ejemplo son superllaves. Muchas veces se prefiere contar con una llave lo más pequeña posible, pues es necesario que podamos comparar rápidamente un par de tuplas para determinar si son idénticas o no. Para esto, introducimos la noción de llave candidata. Una llave candidata es una superllave tal que ningún subconjunto propio de ella también sea superllave, es decir, es minimal. Por ejemplo {vino, año, cepa, presentación} es una superllave pero no una llave candidata, pues {vino, cepa} también es una superllave. Esta última tampoco es llave candidata porque {nombre} también es superllave. Finalmente, {nombre} si es llave candidata, debido a que no hay subconjuntos propios posibles que sean también llave.\nUn atributo que pertenece a una llave candidata se llama atributo primo.\nPara terminar, una llave primaria es alguna de las llaves candidatas que se selecciona como la forma estándar de determinarla igualdad entre tuplas.\nEs necesario notar en este punto, que una relación puede entonces tener más de una llave candidata y estas llaves pueden tener distinta cantidad de atributos. Consideremos el siguiente esquema para almacenar datos de personas:\n Persona(RUT, nombre, fecha_hora_nacimiento, RUT_padre, RUT_madre)  Las llaves candidatas son {RUT} y {RUT_madre, fecha_hora_nacimiento}. 1 Como podemos apreciar, la segunda llave es minimal en el sentido de que no hay un subconjunto de esos atributos que también sea llave, por lo que es una llave candidata a pesar de tener una cantidad de atributos más grande que {RUT}. Sin embargo, probablemente se prefiera utilizar simplemente el RUT como llave primaria porque en este caso es lo más \u0026ldquo;natural\u0026rdquo; además que siempre es mejor tener menos elementos que comparar.\nDependencias Funcionales Dados dos conjuntos de atributos de un esquema relacional $X$ e $Y$, se dice que $Y$ depende funcionalmente de $X$ si para todo par de tuplas $t_1, t_2$ del esquema se cumple que si $t_1[X]=t_2[X]$ entonces $t_1[Y]=t_2[Y]$. 2 Es decir, para cada valor de $X$ hay un único valor de $Y$ posible. Cuando $X$ determina funcionalmente a Y se escribe $X \\rightarrow Y$. Cuando $Y$ es un subconjunto de $X$ se dice que la dependencia funcional es trivial.\nConocer las dependencias funcionales de un esquema es importante para el diseño relacional, pues nos ayudan a determinar si las relaciones propuestas por un modelo pueden o no presentar anomalías.\nInicialmente, se sabe que una llave candidata determina funcionalmente a todos los atributos. Sin embargo, es posible que otros atributos se determinen entre ellos. Supongamos que contamos con la siguiente información de contacto:\n Contacto(RUT, email, dirección, comuna, región)  Claramente el RUT e email son llaves candidatas y, por lo tanto, determinan funcionalmente a todo el resto de los atributos. Por otro lado también sabemos que una comuna se encuentra en una sola región y entonces dos contactos de la misma comuna van a estar necesariamente en la misma región. Entonces sabemos que {comuna} $\\rightarrow$ {región}. Como los nombres de calles pueden repetirse entre comunas, podemos descartar la dependencia {dirección} $\\rightarrow$ {comuna}.\nCuando un esquema cuenta con varias dependencias funcionales, podemos razonar lógicamente sobre ellas y concluir otras dependencias nuevas y coherentes con el esquema. Existe un conjunto de reglas de razonamiento que nos permite obtener el conjunto completo de dependencias funcionales de un esquema, a partir de un conjunto inicial. Estas reglas se conocen como los axiomas de Armstrong. Sea $(R, F)$ un esquema de relación $R$ y dependencias funcionales $F$. Se puede obtener el conjunto de todas las dependencias funcionales deducibles desde $F$, es decir, su clausura $F^+$ aplicando las siguientes reglas:\nSean $X$, $Y$, $Z$, $A$ y $B$ conjuntos de atributos de $R$:\n Reflexión: Si $Y\\subseteq X$, entonces $X\\rightarrow Y$ Aumento: Si $X\\rightarrow Y$, entonces $XZ\\rightarrow YZ$ para cualquier $Z$ Transitividad: Si $X\\rightarrow Y$ e $Y\\rightarrow Z$, entonces $X\\rightarrow Z$ Descomposición: Si $X\\rightarrow YZ$, entonces $X\\rightarrow Y$ y $X\\rightarrow Z$ Composición: Si $X\\rightarrow Y$ y $A\\rightarrow B$, entonces $XA\\rightarrow YB$ Pseudo transitividad: Si $X\\rightarrow Y$ y $YZ\\rightarrow A$, entonces $XZ\\rightarrow A$ Autodeterminación: $X\\rightarrow X$ Extensión: Si $X\\rightarrow Y$, entonces $X\\rightarrow XY$  Los axiomas de Armstrong son especialmente útiles para encontrar las llaves candidatas de las relaciones, pues basta con encontrar aquellos conjuntos de atributos que determinan funcionalmente a todos los demás. Por ejemplo consideremos $R(A,B,C,D,E)$ y las siguientes dependencias:\n $A\\rightarrow E$ $BC\\rightarrow D$ $E\\rightarrow B$  Por transitividad, sabemos que $A\\rightarrow B$ y por aumento que $AC\\rightarrow CE$ y $AC\\rightarrow BC$. Nuevamente la transitividad nos indica que $AC\\rightarrow D$. Finalmente, uniendo todos los resultados, tenemos que $AC\\rightarrow ABCDE$, por lo que $AC$ es la llave de $R$. Este proceso de aplicar reglas exhaustivamente a un conjunto de atributos para encontrar todos los otros que son determinados funcionalmente por ellos, se llama calcular la clausura de ese conjunto de atributos. En este caso $AC^+$.\nTal vez haya parecido un procedimiento antojadizo, pero la intuición detrás del éste es seleccionar los atributos que no aparecen en el lado derecho de las dependencias para comenzar. En este caso $A$ y $C$.\nReferencias  Armstrong, William. Dependency Structures of Data Base Relationships, page 580-583. IFIP Congress, 1974. Ramakrishnan, Raghu, and Johannes Gehrke. Database management systems. McGraw Hill, 2000.    {RUT_padre, fecha_hora_nacimiento} no se considera, pues puede suceder que un hombre tenga hijos con dos mujeres distintas que por coincidencia nacieron el mismo día y a la misma hora. \u0026#x21a9;\u0026#xfe0e;\n En este artículo se considera que si $t$ es una tupla y $X$ es un conjunto atributos, la operación $t[X]$ corresponde a la proyección de los atributos $X$ de la tupla $t$, es decir $\\pi_X(t)$ \u0026#x21a9;\u0026#xfe0e;\n   ","date":1540831403,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1540831403,"objectID":"31a0b3a0ecc5cfd6fadcf1ea2d488d2d","permalink":"http://www.sferrada.com/post/functional-dependencies/","publishdate":"2018-10-29T13:43:23-03:00","relpermalink":"/post/functional-dependencies/","section":"post","summary":"Este post provee de una introducción al concepto de llaves y dependencias funcionales en el campo de la teoría de las bases de datos relacionales. Está guiado por ejemplos, pero se presentan también algunas de las formalidades matemáticas.","tags":["Databases","Relational Design","Functional Dependencies"],"title":"Llaves y Dependencias Funcionales","type":"post"},{"authors":null,"categories":null,"content":"","date":1538481601,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1538481601,"objectID":"b4cfd73ae04ae3e920a62876c887f8a1","permalink":"http://www.sferrada.com/talk/clei-cltm18/","publishdate":"2018-10-02T09:00:01-03:00","relpermalink":"/talk/clei-cltm18/","section":"talk","summary":"IMGpedia is a large-scale linked dataset that incorporates visual information of the images from the Wikimedia Commons dataset: it brings together descriptors of the visual content of 15 million images, 450 million visual-similarity relations between those images, links to image metadata from DBpedia Commons, and links to the DBpedia resources associated with individual images. In this paper we describe the creation of the IMGpedia dataset, provide an overview of its schema and statistics of its contents, offer example queries that combine semantic and visual information of images, and discuss other envisaged use-cases for the dataset","tags":["Masters Thesis","Visuo-semantic Queries","Web Image Retrieval","Semantic Web","IMGpedia"],"title":"IMGpedia at CLTM-CLEI","type":"talk"},{"authors":["Sebastián Ferrada","Benjamin Bustos","Nora Reyes"],"categories":null,"content":"","date":1526875200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1526875200,"objectID":"262445c5dbc50cbcc2d32168229f3562","permalink":"http://www.sferrada.com/publication/ferrada-simple-2018/","publishdate":"2018-05-21T00:00:00-04:00","relpermalink":"/publication/ferrada-simple-2018/","section":"publication","summary":"The use of the join operator in metric spaces leads to what is known as a similarity join, where objects of two datasets are paired if they are  somehow  similar. We propose an heuristic that solves the 1-NN self-similarity join, that is, a similarity join of a dataset with itself, that brings together each element with its nearest neighbor within the same dataset. Solving the problem using a simple brute-force algorithm requires $O(n^2)$ distance calculations, since it requires to compare every element against all others. We propose a simple divide-and-conquer algorithm that gives an approximated solution for the self-similarity join that computes only $O(n^\\frac{3}{2}) $ distances. We show how the algorithm can be easily modified in order to improve the precision up to 31% (i.e., the percentage of correctly found 1-NNs) and such that 79% of the results are within the 10-NN, with no significant extra distance computations. We present how the algorithm can be executed in parallel and prove that using $\\Theta(\\sqrt{n})$ processors, the total execution takes linear time. We end discussing ways in which the algorithm can be improved in the future.","tags":null,"title":"A Simple, Efficient, Parallelizable Algorithm for Approximated Nearest Neighbors.","type":"publication"},{"authors":["Sebastián Ferrada","Nicolás Bravo","Benjamin Bustos","Aidan Hogan"],"categories":null,"content":"","date":1524283200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1524283200,"objectID":"b4c278e9b824e0530ec82c9fc239427f","permalink":"http://www.sferrada.com/publication/ferrada-querying-2018/","publishdate":"2018-04-21T00:00:00-04:00","relpermalink":"/publication/ferrada-querying-2018/","section":"publication","summary":"","tags":["IMGpedia","Multimedia","SPARQL","Visuo-semantic Queries","Wikidata"],"title":"Querying Wikimedia Images using Wikidata Facts","type":"publication"},{"authors":["Sebastián Ferrada Aliaga"],"categories":null,"content":"IMGpedia es una base de datos enlazados que extrae características visuales a las imágenes de Wikimedia Commons y que provee enlaces a DBpedia al contexto de la imagen, permitiendo así realizar consultas visuo-semánticas. IMGpedia fue mi tesis de magíster guiada por Benjamin Bustos y Aidan Hogan. Muy probablemente será mi tesis de doctorado también. En este post les voy a contar de qué se trata IMGpedia y mi experiencia compartiendo este trabajo en ISWC 2017 en Viena, Austria.\nLa idea que motiva el trabajo es incluir fuertemente el análisis de contenido multimedia en la Web de Datos, tomando en cuenta que la información multimedia es parte fundamental para la experiencia de los usuarios en la Web. IMGpedia nos permitiría poder hacer consultas de similitud visual entre imágenes, obtener imágenes que cumplan un cierto predicado y mezclar ambos enfoques, lo que llamamos una consulta visuo-semántica. Por ejemplo, nos permitiría responder la siguiente consulta: dada una imagen de la catedral de Cusco, obtener imágenes similares de catedrales europeas.\nPara lograr el objetivo, debemos seguir la siguiente metodología:\n Obtener las imágenes para procesarlas localmente. Calcular los descriptores visuales (vectores de características) de las imágenes. Obtener estáticamente relaciones de similitud entre las imágenes. Enlazar las imágenes con otras fuentes de información (DBpedia, Wikidata, Freebase). Publicar todo como RDF, a través de un terminal SPARQL.  Descargar los 14,7 millones de imágenes nos tomó 40 días con múltiples conexiones. El tamaño total de las imágenes es de 22 Terabytes. Una vez descargadas, calculamos los descriptores visuales, en particular calculamos histogramas de grises, histogramas de la orientación de los bordes y un descriptor basado en color. Puedes encontrar más detalles sobre los descriptores y código visitando el GitHub del proyecto (en inglés).\nComo se puede ver en la Figura 1, nuestro objetivo es enlazar las imágenes que sean visualmente similares. Para hacer esto, tomamos un descriptor y encontramos sus 10 vecinos más cercanos, pues asumimos que si dos vectores están cerca, es por que son similares. Esta decisión de tomar los k vecinos más cercanos ha generado mucha discusión, pero si están interesados, hay una reflexión al respecto al final del post.\n**Figura 1:** Similitud entre imágenes Luego, necesitamos obtener contexto de la imagen: saber qué es, cómo se llama lo que aparece en ella o con qué está relacionada. Para esto, usamos un dump de la Wikipedia en inglés para reunir los pares (nombre_img, nombre_wiki) de modo que la imagen aparece en la wiki. Entonces enlazamos la imagen con el recurso de DBpedia relacionado al articulo de Wikipedia correspondiente. Por ahora, nada nos asegura que la imagen realmente contenga a la entidad con la que está relacionada, pero sí podemos decir que la imagen está asociada a la entidad de alguna forma u otra. En la Figura 2 se muestra lo que se pretende hacer, por ejemplo si una imagen aparece en la wiki de Quentin Tarantino, entonces enlazamos la imagen con el recurso de Tarantino en DBpedia.\n**Figura 2:** Obtener contexto de la imagen Finalmente, publicamos todo en formato RDF que puede ser consultado a través de un terminal público de SPARQL. Los datos tienen un cierto esquema para modelar clases y atributos que puede ser encontrado aquí En este terminal, podemos hacer por ejemplo las siguientes consultas:\n Obtener todas las imágenes similares a la foto de Hopsten Marktplatz:  SELECT DISTINCT ?Target WHERE { im:Hopsten_Marktplatz_3.jpg imo:similar ?Target . }  **Figura 3:** Resultados de la consulta a  Obtener imágenes de las pinturas hechas el siglo XVI, que están en exposición en el Louvre (ojo que también podemos obtener otros datos como el nombre de la pintura, quién la pintó, etc.):  SELECT DISTINCT ?url ?label WHERE { SERVICE \u0026lt;https://dbpedia.org/sparql\u0026gt; { ?res a yago:Wikicat16th-centuryPaintings ; dcterms:subject dbc:Paintings_of_the_Louvre ; rdfs:label ?label . FILTER(LANG(?label)=\u0026quot;en\u0026quot;) } ?img imo:associatedWith ?res ; imo:fileURL ?url . }  **Figura 4:** Resultados de la consulta b  Finalmente podemos combinar ambos tipos de preguntas en una consulta que llamamos visuo-semántica, por ejemplo entre todas las imágenes de catedrales europeas, obtener imágenes similares que sean museos:  SELECT DISTINCT ?source ?target WHERE { SERVICE \u0026lt;https://dbpedia.org/sparql\u0026gt; { ?sres dcterms:subject/skos:broader* dbc:Roman_Catholic_cathedrals_in_Europe } ?source imo:associatedWith ?sres ; imo:similar ?target . ?target imo:associatedWith ?tres ; imo:fileURL ?urlt . SERVICE \u0026lt;https://dbpedia.org/sparql\u0026gt; { ?tres dcterms:subject ?subject . FILTER(CONTAINS(STR(?sub), “Museum”))} }  **Figura 5:** Resultados de la consulta c Tras mi defensa del Magister, este trabajo fue aceptado en el track de recursos de la 16ta Conferencia Internacional de la Web Semántica (ISWC) y viajé a Viena a presentarlo, puedes encontrar las diapositivas aquí. También participamos en la sesión de pósters, donde recibimos feedback y preguntas muy interesantes, puedes ver el póster aquí. Tanto la presentación como la sesión de pósters fueron una gran oportunidad para validar nuestro trabajo, para saber cómo mejorarlo y para saber qué cree la comunidad que sería útil agregar. En resumen, dejo algunos puntos:\n Redes Neuronales: el 90% de las personas que pasaron por mi póster me dijeron que no podían faltar. Ya sea para clasificar el contenido, como para obtener otros descriptores visuales o incluso para predecir triples con hechos sobre las imágenes. Consultas por rango: muchos, al igual que yo, notan que el tener k vecinos más cercanos por imagen es bastante restrictivo: hay relaciones interesantes que se pierden y forzamos a otras imágenes a ser similares a k otras. Sin embargo, hacerlo de esta forma en la primera versión nos ayudó a comprender cómo se comporta la distribución de distancias entre imágenes similares, por lo que podemos proponer un umbral más ajustado en una próxima versión. Enlazar a otas bases de conocimiento: DBpedia es una fuente de información muy útil, pero ha resultado ser poco flexible para nuestros propósitos. Muchos piensan que enlazar con otras bases de conocimiento como Wikidata o Yago, puede enriquecer y darle mayor expresividad a las consultas de IMGpedia.  ¡Gracias a todos los que nos fueron a ver al stand!\n**Figura 6:** Sesión de pósters Para terminar con esta historia, el último día de conferencia anuncian a los ganadores de los mejores papers publicados en la conferencia. ¡IMGpedia ganó dos premios! Ganamos el premio al mejor póster y el premio al mejor paper de estudiante en el track de recursos (junto con BiOnIC). Este reconocimiento significa mucho para mi y para mi carrera de científico, ¡vaya forma de comenzar! Y más aún, porque los otros nominados son varios estudiantes de doctorado de centros y universidades reconocidos a nivel mundial, como la Universidad de Standford. Más aún cuando mi trabajo es una tesis de magíster, es increíble que haya competido contra otros trabajos de tan alto nivel. Además este premio, como el mejor paper de estudiantes del track de investigación de ISWC es un claro mensaje de que tenemos que seguir trabajando en multimedia, no podemos seguir dejando estos datos de lado. Ahora queda seguir trabajando y mejorando IMGpedia, para que se convierta en la base de conocimiento estándar para las imágenes de la Web.\nQuiero destacar también el nivel de ciencia que se desarrolla en los institutos y centros de investigación chilenos financiados por la Iniciativa Científica Milenio, en particular en el Núcleo Milenio Centro de investigación de la Web Semántica, que en total nos llevamos 3 premios en ISWC (los dos de IMGpedia y el premio a mejor paper de investigación para Jorge Pérez).\n**Figura 7:** Aidan y yo recibiendo el premio a mejor paper de estudiante Solo me falta agradecer a todos los que hicieron este (arduo) trabajo posible, en especial a mis profesores guía, Benjamin y Aidan; a Sergio Aguilera por ayudarme tanto con la mantención del servidor; a Camila Faúndez por el trabajo enlazando las imágenes a sus respectivos artículos; al Núcleo Milenio Centro de Investigación de la Web Semántica, por su apoyo financiero y académico; y a toda mi familia y amigos por su constante apoyo, motivación y cariño.\n Sobre los 10 vecinos más cercanos: Es cierto que al tomar esta decisión suceden dos cosas indeseables. Primero, es posible que se pierdan relaciones de similitud relevantes, es decir que el 11mo, 12mo, etc. sean muy similares también. Segundo, estamos forzando que si hay imágenes que no se parecen a nada, se parezcan a al menos 10. La justificación detrás de esta decisión tiene dos partes. Por un lado lo que pretendemos es mantener una cantidad acotada de triples RDF, después de todo, esta es la primera versión de IMGpedia y necesitábamos probar el concepto primero. Por otro lado, tener estas relaciones de los 10 vecinos más cercanos y sus distancias en los diferentes espacios vectoriales nos dan una visión más amplia sobre la distribuciónde las distancias, permitiéndonos en el futuro utilizar una consulta por rango, utilizando estrategias de indexamiento y un umbral de distancia apropiado para cada descriptor.\n","date":1509054203,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1509054203,"objectID":"9f066239c846b24ea788dcd544f27706","permalink":"http://www.sferrada.com/post/imgpedia-iswc/","publishdate":"2017-10-26T18:43:23-03:00","relpermalink":"/post/imgpedia-iswc/","section":"post","summary":"IMGpedia es una base de datos enlazados que extrae características visuales a las imágenes de Wikimedia Commons y que provee enlaces a DBpedia al contexto de la imagen, permitiendo así realizar consultas visuo-semánticas.","tags":["IMGpedia","ISWC","Linked Data","Multimedia"],"title":"IMGpedia, la importancia de incluir multimedia en la Web de Datos","type":"post"},{"authors":null,"categories":null,"content":"","date":1508760001,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1508760001,"objectID":"f3ed7bac4a98503786eea4a181cfd579","permalink":"http://www.sferrada.com/talk/imgpediaiswc17/","publishdate":"2017-10-23T14:00:01+02:00","relpermalink":"/talk/imgpediaiswc17/","section":"talk","summary":"IMGpedia is a large-scale linked dataset that incorporates visual information of the images from the Wikimedia Commons dataset: it brings together descriptors of the visual content of 15 million images, 450 million visual-similarity relations between those images, links to image metadata from DBpedia Commons, and links to the DBpedia resources associated with individual images. In this paper we describe the creation of the IMGpedia dataset, provide an overview of its schema and statistics of its contents, offer example queries that combine semantic and visual information of images, and discuss other envisaged use-cases for the dataset","tags":[],"title":"IMGpedia at ISWC","type":"talk"},{"authors":["Sebastián Ferrada","Benjamin Bustos","and Aidan Hogan"],"categories":null,"content":"","date":1508727600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1508727600,"objectID":"53af5ebea5f45ea5fff6614e5e2aca8d","permalink":"http://www.sferrada.com/publication/ferrada-imgpedia-2017/","publishdate":"2017-10-23T00:00:00-03:00","relpermalink":"/publication/ferrada-imgpedia-2017/","section":"publication","summary":"IMGpedia is a large-scale linked dataset that incorporates visual information of the images from the Wikimedia Commons dataset: it brings together descriptors of the visual content of 15 million images, 450 million visual-similarity relations between those images, links to image metadata from DBpedia Commons, and links to the DBpedia resources associated with individual images. In this paper we describe the creation of the IMGpedia dataset, provide an overview of its schema and statistics of its contents, offer example queries that combine semantic and visual information of images, and discuss other envisaged use-cases for the dataset.","tags":["IMGpedia","Multimedia","SPARQL","Visuo-semantic Queries"],"title":"IMGpedia: a linked dataset with content-based analysis of Wikimedia images","type":"publication"},{"authors":null,"categories":null,"content":"","date":1499432400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1499432400,"objectID":"90d74fba3d87c1b835ed65a9448eb140","permalink":"http://www.sferrada.com/talk/mscdefense/","publishdate":"2017-07-07T10:00:00-03:00","relpermalink":"/talk/mscdefense/","section":"talk","summary":"Since its beginning, the Web of Data has been focused on the curation and production of machine-understandable representations of the textual information on the Web, being multimedia information mostly disregarded. In this talk, we present IMGpedia: a novel knowledge-base that automatically extracts visual features from Wikimedia Commons images in order to enable combining visual similarity queries amongst images with semantic filters.","tags":[],"title":"IMGpedia: a Large-scale Knowledge-base to perform Visuo-semantic Queries over Wikimedia Commons Images","type":"talk"},{"authors":null,"categories":null,"content":"","date":1496689200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1496689200,"objectID":"1c04814c25e43ece6e7f8ed7ffc5d0a0","permalink":"http://www.sferrada.com/talk/amw17-poster/","publishdate":"2017-06-05T17:00:00-02:00","relpermalink":"/talk/amw17-poster/","section":"talk","summary":"","tags":[],"title":"AMW 2017 School - Poster Session","type":"talk"},{"authors":["Sebastián Ferrada","Benjamin Bustos","Aidan Hogan"],"categories":null,"content":"","date":1483239600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483239600,"objectID":"f161a525997dbc24e9f66a6a0838e866","permalink":"http://www.sferrada.com/publication/ferrada-answering-2017/","publishdate":"2017-01-01T00:00:00-03:00","relpermalink":"/publication/ferrada-answering-2017/","section":"publication","summary":"IMGpedia is a linked dataset that provides a public SPARQL endpoint where users can answer queries that combine the visual similarity of images from Wikimedia Commons and semantic information from existing knowledge-bases. Our demo will show example queries that capture the potential of the current data stored in IMGpedia. We also plan to discuss potential use-cases for the dataset and ways in which we can improve the quality of the information it captures and the expressiveness of the queries.","tags":["IMGpedia","Multimedia","SPARQL","Visuo-semantic Queries"],"title":"Answering Visuo-Semantic Queries with IMGpedia.","type":"publication"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"52a607107ddc8444c504f90bd54ea709","permalink":"http://www.sferrada.com/project/constitucion-abierta/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/constitucion-abierta/","section":"project","summary":"Visualizing the results of the Chilean constitutional process.","tags":["Visualization"],"title":"Constitución Abierta","type":"project"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"5bd4a702defc0711e3d7e45c26069847","permalink":"http://www.sferrada.com/project/imgpedia-project/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/imgpedia-project/","section":"project","summary":"Combining visual and semantic queries on the Web.","tags":["Multimedia","Linked Data"],"title":"IMGpedia project","type":"project"},{"authors":["Sebastián Ferrada","Benjamin Bustos","Aidan Hogan"],"categories":null,"content":"","date":1451617200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1451617200,"objectID":"48a95ca009c747f25ae87212ac7cae5d","permalink":"http://www.sferrada.com/publication/ferrada-imgpedia-2016/","publishdate":"2016-01-01T00:00:00-03:00","relpermalink":"/publication/ferrada-imgpedia-2016/","section":"publication","summary":"","tags":["IMGpedia","Multimedia","SPARQL","Visuo-semantic Queries"],"title":"IMGpedia: Enriching the Web of Data with Image Content Analysis.","type":"publication"}]